# 1. Two Sum

https://leetcode.com/problems/two-sum/

---

### Read and understand the problem

An array of integer elements, where there can be repeated integer values, but two elements in that array add up to a target value, which is given to us. 

These two element's position in the given array should be returned as an 2 element array

---

### Approach towards the solution you want to code

#### Brute Force solution:

Just write down a loop that runs through every element, and a second loop which through every element after that.

Check every combination, for each element and the elements that come after that.

Code: tested in Python Tutor

```python
def TwoSum(nums, target):
    i = 0
    # loop 1 as explained in approach
    for num1 in nums:
        j = i+1    
        # loop 2 to check every element after the loop 1 element
        for num2 in nums[j:]:
            # checking condition
            if num1 + num2 == target:
                return [i,j]
            j += 1
        i += 1
    return None
    
nums = [2,7,11,15]
target = 9
ans = TwoSum(nums, target)
print(ans)

# all three testcases worked
# [3,2,4],[6,6] - target = 6
```

The solution coded is in O(n2)

---

Understanding solutions:

Concepts: **Hash maps/ Hashing/ Hash Table**

Basically, thought of another approach using an array of arrays, where each element is a 2 element array, with the current value and its index. 

For example: 

```python
nums = [2,7,11,15]
new_nums = [[2,0],[7,1],[11,2],[15,3]]
#Even in this approach, nothing changes, we still have to go through every element to check for the target's complement.
```

My thought process here was to use the indexing to come out with a fast search through solution to find the elements.

So, I had to take a look at the solutions, and understand what the approaches were, concept of hashing is close to the thought process I came up with. 

### Hashing

learning resource: https://stackoverflow.com/questions/15469795/why-hashmap-lookup-is-o1-i-e-constant-time

I can vaguely explain how a hash table works ? and why hash tables support lookup very efficiently. 

Hash tables have a key - pair values which are in certain buckets (an internalized array concept which can be accessed using a hash code), these hash codes are generated using a hash function.

Initially while setting up the hash table, Hash function is applied on the key to get a particular hash code, which can be used directly to access an array element(bucket). So, this reversing the same concept, while accessing the elements, this hash code can be directly used to access the value when a key is given to us in almost linear time. Because, when a key is given to us, we can apply the hash function in linear time, and find the hash code for a particular key and find the value form the bucket.

Technically, it is not linear, in worst case scenario(there can be collisions in a bucket) it can take up to O(n) as well. But on an average, the time complexity is linear O(1). 

Yet to do: 

- [ ] How to implement a hash map

- [ ] Code one pass and two pass hash map solution for the problem

---

Repeat approach and coding the solution, like REPs

---